React 18之后推崇的hook方式，函数式变成极大的改变了搬砖代码的形态。这里对几个常见的内建的hook做一个心得总结。

## useRef
`useRef.current` 是 React 中 `useRef` 钩子返回的对象的一个属性。`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数[3][4]。这个 ref 对象在组件的整个生命周期内保持不变[4]。

`useRef` 的主要功能有两个：
1. 获取 DOM 元素或组件实例：通过将 ref 对象赋值给组件或 DOM 元素的 `ref` 属性，可以获取到对应的实例或元素[1][2][3].
2. 保存在组件生命周期内不会变化的值：通过修改 `useRef.current` 属性的值，可以在组件的多次渲染中保存一个不会变化的值[3][4].

以下是一个使用 `useRef.current` 的示例：

```jsx
import React, { useRef } from 'react';

function ExampleComponent() {
  const countRef = useRef(0);

  const incrementCount = () => {
    countRef.current += 1;
    console.log(countRef.current);
  };

  return (
    <div>
      <h2>Example Component</h2>
      <button onClick={incrementCount}>Increment</button>
    </div>
  );
}
```

在上面的示例中，我们创建了一个 `countRef` ref 对象，并将其初始化为 0。每次点击按钮时，我们通过修改 `countRef.current` 属性的值来增加计数，并将其打印到控制台上。

需要注意的是，修改 `useRef.current` 的值不会引发组件重新渲染[3]。因此，`useRef` 是一个有助于在函数组件中保存可变状态的工具，而不会触发不必要的渲染。
- [1].[你知道useRef可以实现哪些功能吗？ - 稀土掘金](https://juejin.cn/post/6894963612687958024)
- [2].[了解useRef 一篇就够了 - 墨滴](https://mdnice.com/writing/6d957aea187945ddbb2b409fb27dfb03)
- [3].[【React Hooks】useRef 用法原创 - CSDN博客](https://blog.csdn.net/qq_45677671/article/details/116707927)
- [4].[React Hook学习(useRef) - Zoeice](http://zoeice.com/react-hook-useRef/)
- [5].[React新文档：不要滥用Ref哦！ - 51CTO](https://www.51cto.com/article/711707.html), The content generated by the language model comes from the Internet and search engines, which does not mean that this site agrees with its views and is responsible for its authenticity

## useState
可以理解为数值驱动的状态，可以设置字符串，数值，布尔，数组，对象,但是它和vue的`ref（）`最大的区别是，它是`push-base`的，需要手动通过`setState`去触发更新，而`vue`是`pull-base`的，会向全局广播其数据的更新

[update arrays with React useState Hook without Push ](https://www.techiediaries.com/react-usestate-hook-update-array/)

## useEffect
一开始认为它是生命钩子函数的，在组件挂载时候主动运行一次，默认如果没有第二个参数的话，会鬼畜起来

后来发现它好像是一个容易应急的管闲事且能管闲事的大妈,只要告诉它需要管谁的闲事。vue的`Watchers`可能就是来源于此

一般起步教程，都在里边请求挂载后的第一次数据，当然第二个数据传一个空的数组，意味就干挂载后第一次请求的事情，这里需要注意到是，因为异步请求的需要，`fetch`和`axios`都会隐式返回一个`promise`,还有的说法是`useEffect`返回的是`cleanup function`[了解React的useEffect清理功能 ](https://juejin.cn/post/7070703117817348109),不能返回一个`promise`

这里插进来的`clearup`话题，有必要搞清楚，[官方文档中关于cleanup function的介绍](https://legacy.reactjs.org/docs/hooks-effect.html#effects-with-cleanup)

所以需要让请求函数函数这一坨放到即时处理函数里边，或者定义这个函数，在从后边调用它[useAsyncEffect: The Missing React Hook](https://marmelab.com/blog/2023/01/11/use-async-effect-react.html)

在后来，发现其实它有很多问题，后来出现了专门的请求库，来代替它在请求界的地位

之所以有这么花活，要追溯到这个函数`useEffect`的定义和出现的原因，这里有篇文章描述的很好
>Using the useEffect hook to trigger asynchronous(异步) side effects is a common React pattern.使用useeffect钩子函数触发异步副作用是常见的React模式

**每一个**组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。

出现了，`useEffect`拿到的 `state`（私有变量）和`props`（传递的属性），无论在什么时候取都是那一帧的数据，并不是最新的数据

相应的可以用`useref`获取到最新的数据

##参考
[了解React的useEffect清理功能](https://juejin.cn/post/7070703117817348109)
[A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)
[精读《useEffect 完全指南》](https://juejin.cn/post/6844903806090608647)
[useAsyncEffect: The Missing React Hook](https://marmelab.com/blog/2023/01/11/use-async-effect-react.html)
[React Cookbook中文版](https://weread.qq.com/web/reader/8c432530813ab7f0dg018da4k17e328b022b17e62166fad4?)
[nextjs官网的制作细节](https://rauno.me/craft/nextjs)
[React技术揭秘](https://react.iamkasong.com/)
[Build your own React(中文版)](https://qcsite.gatsbyjs.io/build-your-own-react/)
[Build your own React](https://pomb.us/build-your-own-react/)
[https://mp.weixin.qq.com/s/m3a6vjp8-c9a2EYj0cDMmg](https://mp.weixin.qq.com/s/m3a6vjp8-c9a2EYj0cDMmg)
[React 哲学 – React](https://zh-hans.react.dev/learn/thinking-in-react)