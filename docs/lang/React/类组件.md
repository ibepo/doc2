## 原理
组件就是封装了html、css、js 及其其他多媒体资源的集合，做到自给自足，按数据而动
类组件，被react发现后，new出来一个实例对象，这个实力对象中挂载了`React`提供的一些属性和你自定义的一些挂载到原型链上的方法,
并且在`render（）`方法中，返回类似html的标签，这便是虚拟dom了
类组件的核心是通过继承`React.Component`,得到组件的能力

需要提前复习的是，this永远指向调用它的那个实例
`render()`中用到的数据`this.state`，恰好是这个类组件实例的构造器`constructor()`中放入实例中的，后边你会看到它也可以以自定义类属性的形式放到类的实例上,（这里区别与函数组件,函数组件上是没有`this`的）
所以可以在`reader（）`中，通过解构赋值的方式拿到具体的某个值
``` js
class Weather extends React.Component{
  constructor(props){
   super(props)
   this.state= {isHot:false}
  }
  render(){
  const {isHot} = this.state
  return <h1>今天天气很{isHot？'炎热':'凉爽'}</h1>
  }
}
```

## 组件实例上三个重要属性
`三点展开式` `setState`
- state,状态，组件实例对象身上的数据
- props,本组件之外传递过来的数据
- refs
- context

`state`之所以是`state`,是因为他只能通过`setState`传递，并且这个更新是一个合并操作，不是操作，如果只是修改部分键值对，其他的键值对会原样奉还
批量传递`props`,是可以用`JSX`语法中的对象展开`{...object}`,这里区别于`ES6`的三点展开，那个只能展开数组

## 事件绑定
`原生dom事件绑定`  `React中的事件绑定`

### 原生的事件绑定
``` js
//第一种方法
const btn1=doncument.getElementById('btn1')
btn1.addEventListener('click',()=>{
alert('按钮1被点击了')
})
//第二种方法
const btn2=doncument.getElementById('btn2')
btn2.onclick=()=>{
alert('按钮2被点击了')
}
```

### React事件绑定
React中的事件绑定，因为React把事件指向了类组件之外的一个函数,作为回调，这个函数是拿不到类组件中的`this`的,所有有一个本办法是，在`constuctor`中将`that=this`，将this缓存到一个全局变量中，
再在事件函数中调用`that.state`
类组件中的`render`方法返回的类似html结构的`JSX`中，将html的标签的属性都额外定义了一边，以React自身解析之用,例如`onclick`==>`onClick`,`class`==>`className`,这里简单复习，原生的两种绑定点击时间的方法
``` js
//第三种，在React中，请用一下方式
//html中一些原生标签属性，在jsx中都有其替代品，例如这里的onclick==>onClick
//注意这里的函数名不要加（），执行它
let that;
class Demo extends React.Componet{
  render(){
  const {isHot} = this.state
  return <h1 onClick={changeWeather}>今天天气很{isHot？'炎热':'凉爽'}</h1>
  }

function changeWeather(){
  that.state.isHot=!that.state.isHot;
}
```

## this的指向问题
`原型链`  `this`  `类构造器`
我们预期的是将方法全部放到类里边，这样`this`就是类组件实例的，在实例中调用其内部的方法，得用`this.functionName`这种方式[类中方法中的this](https://www.bilibili.com/video/BV1wy4y1D7JT?t=665.0&p=15)
构造器中的`this`一定是当前类的实例对象
`render`是被new的实例对象调用，
[类中方法中的this](https://www.bilibili.com/video/BV1wy4y1D7JT?t=1125.6&p=15)
由于自定义函数是作为`onClick`的回调，所以不是通过实例调用的，是直接调用，
类中所有自定义的方法，它自局部开好了严格模式
所以自定义函数中的`this`指向`undefined`
解决方式
`this.changeWeather=this.changWeather.bind(this)`

## 类组件的标准做法
`类组件属性`  `箭头函数的this`
类中自定义的属性，可以直接传递到类的实例当中
类中通过箭头函数定义的方法，其箭头函数内部`this`指向和外部的一致，在这里就是类的实例
这样就规避了反复通过`bind()`，一次一次的将原型链中的自定义方法绑定到类实例上的反复操作

``` js
class MyComponets extends React.component{
  constuctor{
   
   }

  state={age:12,name:'kobe',isHOt:true}

  render(){
   const {isHot} = this.state
   return <h1 onClick={changeWeather}>今天天气很{isHot？'炎热':'凉爽'}</h1>
  }

  const changeWeather=()=>{
  this.state.isHot=!this.state.isHot
  }
  
}
```
